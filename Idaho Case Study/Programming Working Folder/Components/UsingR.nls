to setupStage0R
  clear-all
end

to setupStage1R
  ;; SetupR is different than the other setups. This is only used for simulation of experiments.
  ;; Therefore, there is no random generation option.

  set Is-Setup? false
  if FixRandomSeed? = TRUE [random-seed RandomSeed]
  set Finished FALSE ; Finished is a status variable for use in BehaviorSpace - gives the simulation an indicator of when it can quit.
  reset-timer ; Reset the timer so it can be used to track system performance - primarily relevant during testing, don't care as much during actual simulations.
  reset-ticks
  if Animate? = TRUE [ animate ]  ; If the setting on the interface says to animate, then go through the process of showing the context and specific simulation location.
  PopulateExperimental
end

to setupStage2R
  ;;Although it is useful to be able to set things manually like above, it's simpler to import a file that resets things. Can use R to automatically iterate through this.
  ; ImportExperimentVariables is done through R so the variables can be different from the original world.
  ask farmers [
    set ChangedWaterManagementThisYear? 0
    set AmountFarmerIsWillingToLose random-normal ExperimentalToleranceforLoss ((PercVarWillingnessToLose / 100) * ExperimentalToleranceforLoss)
  ]

  ; This would be the moment to change the working directory in MATLAB if using AquaCrop.
  ;   matlab:eval "cd '//itsofs06.itap.purdue.edu/ag_fnr/Users/hawes0/GitHub/ESPA-CAMP-ABM/Programming Working Folder/MATLAB'"
  ask farmers [
    CreateCleanDetailedCropBudget
    CreateCleanCropBudget
    CreateCleanSocialCropBudget
  ]
  set NumberOfFarmersWithChangedWM []
  set FinalCSVPrintList []
  set Is-Setup? true

  set location "Initial_post-setup"
  FixRotations
  CatalogConditions location ; Catalog variables that will serve as evaluation criteria - CatalogConditions is a generic cataloging function that names variables based on the time in the model (Initial is the "time" input)
end

to SimulateASeasonR
  ;; This is a new way of running the model. It relies on R calling the command for a given number of seasons.

  trace "start of new tick (year)"
  PlanningSeason  ; Farmers select their acitons for the year. Actions include any kind of water conservation practice, as well as what/how much to plant.
  trace "end of planning for all farmers"
  CropSeason ; Calculate actual returns from choice of land use.
  trace "end of simulation season. Crop outcomes recorded and preparing to reconcile."
  Reconcile ; Balances budgets, finds farmers who are out of money, and checks on the status of the settlement agreement.
  trace "end of season reconciliation. Farmers are now prepared to share outcomes (if not Bounded Rationality) and start new year"
  if Decision-Making != "Bounded Rationality" [ KnowledgeSharing ]
  trace "end of knowledge sharing. Farmers have shared their ideas and are ready for the new planning season"
  tick
  EvaluateSeasonR
end

to EvaluateSeasonR
 
  
  
  ; Evaluating changes to water use strategies this year. 
  let WaterStratChange 0
  ask farmers [
    if ChangedWaterManagementThisYear? = 1
    [ set WaterStratChange WaterStratChange + 1 ]
  ]
  set WaterStratChangePercentR (WaterStratChange / count farmers * 100)
  
  let file-name (word "/Results/" ExperimentName "_SeasonalResult.txt")
  file-open file-name
  file-write (word "Season " ticks)
  file-write "Percent of Farmers who Changed Strategies this year"
  file-write WaterStratChangePercentR
  file-write "Other outputs can end up down here."
  file-close
  
end

to EvaluateRunR
  
;  ; set of commands used to produce easily analyzable information. For instance, produce crop counts or percent who change irrigation strategies.
;
;  ; Evaluating rotations
;  let potato-rot-count 0
;  let beet-rot-count 0
;  let alfalfa-rot-count 0
;  let grain-rot-count 0
;  let barley-rot-count 0
;
;  ask farmers [
;    foreach RotationList [
;      [entry] ->
;      if entry = "Potato"  [set potato-rot-count potato-rot-count + 1]
;      if entry = "Beet" [set beet-rot-count beet-rot-count + 1]
;      if entry = "Hay" [set alfalfa-rot-count alfalfa-rot-count + 1]
;      if entry = "Grain" [set grain-rot-count grain-rot-count + 1]
;      if entry = "Barley" [set barley-rot-count barley-rot-count + 1]
;    ]
;  ]
;  print (word "potato-rotation-count is " potato-rot-count)
;  print (word "beet-rotation-count is " beet-rot-count)
;  print (word "alfalfa-rotation-count is " alfalfa-rot-count)
;  print (word "grain-rotation-count is " grain-rot-count)
;  print (word "barley-rotation-count is " barley-rot-count)
;  let rot-sum barley-rot-count + grain-rot-count + alfalfa-rot-count + beet-rot-count + potato-rot-count
;  print (word "Percent potato is " (potato-rot-count / rot-sum) " as compared to " CropscapePercentPotatoes " prescribed by cropscape.")
;  print (word "Percent beet is " (beet-rot-count / rot-sum) " as compared to " CropscapePercentSugarbeets " prescribed by cropscape.")
;  print (word "Percent alfafa is " (alfalfa-rot-count / rot-sum) " as compared to " CropscapePercentAlfalfa " prescribed by cropscape.")
;  print (word "Percent grain is " (grain-rot-count / rot-sum) " as compared to " (CropscapePercentSpringWheat + CropscapePercentCorn + CropscapePercentWinterWheat) " prescribed by cropscape.")
;  print (word "Percent barley is " (barley-rot-count / rot-sum) " as compared to " CropscapePercentBarley " prescribed by cropscape.")
;
;  ; Evaluating crop histories
;  set potato-count 0
;  set beet-count 0
;  set alfalfa-count 0
;  set a-p-count 0
;  set alfalfa-total-count 0
;  set sw-count 0
;  set ww-count 0
;  set corn-count 0
;  set grain-count 0
;  set barley-count 0
;  set total-crops 0
;
;  ask farmers [
;    foreach crophistory [
;      [entry] ->
;      if entry = ["Potatoes"]  [set potato-count potato-count + 1]
;      if entry = ["Sugarbeets"] [set beet-count beet-count + 1]
;      if entry = ["Alfalfa"] [set alfalfa-count alfalfa-count + 1]
;      if entry = ["Alfalfa"] [set alfalfa-total-count alfalfa-total-count + 1]
;      if entry = ["Spring Wheat"] [set sw-count sw-count + 1]
;      if entry = ["Spring Wheat"] [set grain-count grain-count + 1]
;      if entry = ["Winter Wheat"] [set ww-count ww-count + 1]
;      if entry = ["Winter Wheat"] [set grain-count grain-count + 1]
;      if entry = ["Corn"] [set corn-count corn-count + 1]
;      if entry = ["Corn"] [set grain-count grain-count + 1]
;      if entry = ["Barley"] [set barley-count barley-count + 1]
;      if entry = ["Alfalfa_Perennial"] [set a-p-count a-p-count + 1]
;      if entry = ["Alfalfa_Perennial"] [set alfalfa-total-count alfalfa-total-count + 1]
;    ]
;  ]
;  set total-crops potato-count + beet-count + barley-count + alfalfa-total-count + grain-count
;  print (word "potato-count is " potato-count)
;  print (word "beet-count is " beet-count)
;  print (word "alfalfa-count is " alfalfa-count)
;  print (word "sw-count is " sw-count)
;  print (word "ww-count is " ww-count)
;  print (word "corn-count is " corn-count)
;  print (word "barley-count is " barley-count)
;  print (word "alfalfa perennial count is " a-p-count)
;  print (word "Alfalfa total count is " alfalfa-total-count)
;  print (word "grain-count is " grain-count)
;  print (word "total-crops is " total-crops)
  
end